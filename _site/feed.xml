<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">LastDay的博客</title>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml" />
<link rel="alternate" type="text/html" href="http://localhost:4000" />
<updated>2015-10-14T14:11:35-04:00</updated>
<id>http://localhost:4000/</id>
<author>
  <name>LastDay</name>
  <uri>http://localhost:4000/</uri>
  <email>lastdays1122@icloud.com</email>
</author>


<entry>
  <title type="html"><![CDATA[我叫ZJXX]]></title>
  <link>http://localhost:4000/personal/first-commit</link>
  <id>http://localhost:4000/personal/first-commit</id>
  <published>2015-10-16T00:00:00-04:00</published>
  <updated>2015-10-16T00:00:00-04:00</updated>
  <author>
    <name>LastDay</name>
    <uri>http://localhost:4000</uri>
    <email>lastdays1122@icloud.com</email>
  </author>
  <content type="html">&lt;p&gt;一个在追求梦想道路上的iOS开发男孩，我坚信着，世界之所以精彩，因为一切皆有可能。我爱我的家庭UIT&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/personal/first-commit&quot;&gt;我叫ZJXX&lt;/a&gt; was originally published by LastDay at &lt;a href=&quot;http://localhost:4000&quot;&gt;LastDay的博客&lt;/a&gt; on October 16, 2015.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[objective-c算法详解(一、链表)]]></title>
  <link>http://localhost:4000/%E9%BE%99%E5%B0%91/first-link</link>
  <id>http://localhost:4000/%E9%BE%99%E5%B0%91/first-link</id>
  <published>2015-10-15T00:00:00-04:00</published>
  <updated>2015-10-15T00:00:00-04:00</updated>
  <author>
    <name>LastDay</name>
    <uri>http://localhost:4000</uri>
    <email>lastdays1122@icloud.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;section&quot;&gt;链表的介绍：&lt;/h1&gt;

&lt;p&gt;链表可以说是一种最为基础的数据结构，在维护集合数据的时候拥有很大的帮助，尤其是在增，删上拥有很大的效率今天总结一下曾经学习的链表。在ios的开发中，掌握一些常用的算法可以帮助我们更加有效率的开发。
链表的总类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单链表&lt;/li&gt;
  &lt;li&gt;双向链表&lt;/li&gt;
  &lt;li&gt;循环链表&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今天先来讲述下单链表：元素之间由一个单独的指针链接。这种结构的链表允许从第一个元素开始遍历到最后一个元素。&lt;/p&gt;

&lt;p&gt;各元素之间通过一个指针连接起来而组成。每个元素包含两个部分：数据成员和一个被称为next的指针。通过这好种结构，将每个元素的next指针设置为指向其后面的元素。最后一个元素的Next设置为NULL，简单的表示链表的尾端。链表开始处的元素是”head“，链表的末尾的元素称为”tail“。&lt;/p&gt;

&lt;p&gt;图一&lt;/p&gt;

&lt;p&gt;根据上面说的，其实我们可以把链表看作一系列连续的元素，要知道这些元素是动态分配在内存中的。其实元素与元素之间的连接是为了保证我们能够访问到每个元素。如果其中有一个链接被丢失，那么从这个链接开始往后的所有链接都将被丢失。&lt;/p&gt;

&lt;p&gt;我曾经在一本书上看过一句话：“你的弱点又多弱，你的强度就有多强”，这句话来形容链表非常的恰当。&lt;/p&gt;

&lt;p&gt;进入今天的主题：&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;单链表接口的定义：&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;初始化链表:&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;
-(void)listInit :(List*) list;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该函数必须在其他操作之前调用。，使用listInit初始化一个链表，方便我们执行其他操作。初始化非常简单，只需要将size设置为0，head与tail设置为null，就完成了初始化操作。&lt;/p&gt;

&lt;h3 id=&quot;element&quot;&gt;在指定的element后添加:&lt;/h3&gt;

&lt;p&gt;```
-(int)listInsNext:(List*) list over:(ListElemt *) element over:(ListElemt *)newElement;&lt;/p&gt;

&lt;p&gt;```
简单的说，插入操作就是对链表进行新的连接，例如有两个节点A和C，要在A节点后加入B节点。首先先让B的next指针指向C。然后C，然后A的next指针指向B。这样就完成了简单的操作。但是但是当插入到head位置的话，新元素前面就没有节点了，这样怎么办？很简单，只需要将新元素next指针指向当前链表的头部就可以了。当传入的element为空，直接插入到头部就可以了。&lt;/p&gt;

&lt;p&gt;图一：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150808165425007&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;element-1&quot;&gt;移除指定element后的元素:&lt;/h3&gt;
&lt;p&gt;```
-(int)listRemNext:(List*) list over:(ListElemt *) element;&lt;/p&gt;

&lt;p&gt;```
移除element身后的元素，而不是element本身，至于为什么，我们后在以后进行说明。需要考虑两点，移除头节点，以及其他节点。
操作其实很简单。例如有A，B，C三个节点，我们只需要申请一个D，让D指向A的下一个元素，然后A的next指向A的next的next。这样连接中我们就将B直接去掉，剩下A，C。之后&lt;a href=&quot;http://www.oschina.net/translate/automatic-reference-counting-on-ios&quot;&gt;ARC&lt;/a&gt;会帮我们自动回收掉B&lt;/p&gt;

&lt;p&gt;图二：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150808165646941&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;输出链表&lt;/h3&gt;

&lt;p&gt;```
-(void)outPut:(List*) list;&lt;/p&gt;

&lt;p&gt;```
采用一个循环，初始化一个指针pre，让这个指针指向list的head。每次循环后进行判断，并且重新规划：pre ＝ pre－&amp;gt;next&lt;/p&gt;

&lt;h3 id=&quot;listlistelemt&quot;&gt;以下为一些宏定义，方便我们快速访问和监测List和ListElemt：&lt;/h3&gt;

&lt;p&gt;```
#define list_size(list)((list)-&amp;gt;size)&lt;/p&gt;

&lt;h1 id=&quot;define-listheadlistlist-head&quot;&gt;define list_head(list)((list)-&amp;gt;head)&lt;/h1&gt;
&lt;p&gt;#define list_tail(list)((list)-&amp;gt;tail)
#define list_is_head(list,element)((element)==(list)-&amp;gt;head ? 1:0)
#define list_is_tail(element)((element)-&amp;gt;next = NULL ? 1：0)
#define list_data(element)((element)-&amp;gt;data)
#define list_next(element)((element)-&amp;gt;data)&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;ListElemt.h代码：&lt;/p&gt;

&lt;p&gt;```
//
//  ListElemt.h
//  ok
//
//  Created by MrLoong on 15/8/8.
//  Copyright (c) 2015年 MrLoong. All rights reserved.
//&lt;/p&gt;

&lt;h1 id=&quot;import-foundationfoundationh&quot;&gt;import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/h1&gt;

&lt;p&gt;@interface ListElemt : NSObject{
    @public id data;
    @public ListElemt *next;
}
@end&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;list.h代码如下：&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;//  List.h
//  Created by MrLoong on 15/8/8.
//  Copyright (c) 2015年 MrLoong. All rights reserved.
//&lt;/p&gt;

&lt;h1 id=&quot;import-foundationfoundationh-1&quot;&gt;import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/h1&gt;
&lt;p&gt;#import “ListElemt.h”&lt;/p&gt;

&lt;p&gt;@interface List : NSObject{
   @public ListElemt &lt;em&gt;head;
   @public ListElemt *tail;
   @public int size;
}
//初始化链表
-(void)listInit :(List&lt;/em&gt;) list;
//在指定的element后添加newElement
-(int)listInsNext:(List&lt;em&gt;) list over:(ListElemt *) element over:(ListElemt *)newElement;
//移除指定element后的元素
-(int)listRemNext:(List&lt;/em&gt;) list over:(ListElemt &lt;em&gt;) element;
//输出链表
-(void)outPut:(List&lt;/em&gt;) list;&lt;/p&gt;

&lt;h1 id=&quot;define-listsizelistlist-size&quot;&gt;define list_size(list)((list)-&amp;gt;size)&lt;/h1&gt;

&lt;h1 id=&quot;define-listheadlistlist-head-1&quot;&gt;define list_head(list)((list)-&amp;gt;head)&lt;/h1&gt;
&lt;p&gt;#define list_tail(list)((list)-&amp;gt;tail)
#define list_is_head(list,element)((element)==(list)-&amp;gt;head ? 1:0)
#define list_is_tail(element)((element)-&amp;gt;next = NULL ? 1：0)
#define list_data(element)((element)-&amp;gt;data)
#define list_next(element)((element)-&amp;gt;data)&lt;/p&gt;

&lt;p&gt;@end&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;list.m代码如下&lt;/p&gt;

&lt;p&gt;```
//
//  List.m
//  ok
//
//  Created by MrLoong on 15/8/8.
//  Copyright (c) 2015年 MrLoong. All rights reserved.
//&lt;/p&gt;

&lt;h1 id=&quot;import-listh&quot;&gt;import “List.h”&lt;/h1&gt;

&lt;p&gt;@implementation List
//初始化链表
-(void) listInit:(List *)list{
    list-&amp;gt;size = 0;
    list-&amp;gt;head = NULL;
    list-&amp;gt;tail = NULL;
    return;
}&lt;/p&gt;

&lt;p&gt;//在元素element后插入newElement&lt;/p&gt;

&lt;p&gt;-(int)listInsNext:(List *)list over:(ListElemt *)element over:(ListElemt *)newElement{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(newElement==NULL){
    return -1;
}

if(element==NULL){
    if(list_size(list)==0){
        list-&amp;gt;tail = newElement;
    }
    newElement-&amp;gt;next = list-&amp;gt;head;
    list-&amp;gt;head = newElement;
    
}
else{
    if(element==NULL){
        list-&amp;gt;tail = newElement;
    }
    newElement-&amp;gt;next = element-&amp;gt;next;
    element-&amp;gt;next = newElement;
}

list-&amp;gt;size++;

return 0; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//移除指定element后的元素
-(int)listRemNext:(List *)list over:(ListElemt *)element{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ListElemt *oldEmement;

if(list_size(list)==0){
    return -1;
}
if (element==NULL) {
    oldEmement = list-&amp;gt;head;
    list-&amp;gt;head = list-&amp;gt;head-&amp;gt;next;
    
    if(list_size(list)==0){
        list-&amp;gt;tail = NULL;
    }
}
else{
    if(element-&amp;gt;next==NULL){
        return -1;
    }
    oldEmement = element-&amp;gt;next;
    element-&amp;gt;next = element-&amp;gt;next-&amp;gt;next;
    
    if(element-&amp;gt;next == NULL){
        list-&amp;gt;tail = element;
    }
}    // free((__bridge void *)(oldEmement));
return 0; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//输出链表
-(void)outPut:(List *)list{
    ListElemt *pre = list-&amp;gt;head;
    while (pre!=nil) {
        NSLog(@”%@”,pre-&amp;gt;data);
        pre = pre-&amp;gt;next;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;} }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@end&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;main.m代码：&lt;/p&gt;

&lt;p&gt;```
//
//  main.m
//  ok
//
//  Created by MrLoong on 15/8/8.
//  Copyright (c) 2015年 MrLoong. All rights reserved.
//&lt;/p&gt;

&lt;h1 id=&quot;import-foundationfoundationh-2&quot;&gt;import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/h1&gt;
&lt;p&gt;#import “List.h”
#import “ListElemt.h”&lt;/p&gt;

&lt;p&gt;int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //创建元素
        List *list = [[List alloc] init];
        [list listInit:list];&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ListElemt *element1 = [[ListElemt alloc]init];
    element1-&amp;gt;data = [NSNumber numberWithInt:1];
    
    ListElemt *element2 = [[ListElemt alloc]init];
    element2-&amp;gt;data = [NSNumber numberWithInt:2];
    
    ListElemt *element3 = [[ListElemt alloc]init];
    element3-&amp;gt;data = [NSNumber numberWithInt:3];
    
    
    ListElemt *element4 = [[ListElemt alloc]init];
    element4-&amp;gt;data = [NSNumber numberWithInt:4];
    
    
    ListElemt *element5 = [[ListElemt alloc]init];
    element5-&amp;gt;data = [NSNumber numberWithInt:5];
    
    ListElemt *element6 = [[ListElemt alloc]init];
    element6-&amp;gt;data = [NSNumber numberWithInt:6];
    //创建元素
    [list listInsNext:list over:list-&amp;gt;head over:element1];
    [list listInsNext:list over:element1 over:element2];
    [list listInsNext:list over:element2 over:element3];
    [list listInsNext:list over:element3 over:element4];
    [list listInsNext:list over:element4 over:element5];
    [list listInsNext:list over:element5 over:element6];

    
    [list outPut:list];
    //删除element2后的元素element3
    [list listRemNext:list over:element2];
    
    printf(&quot;===========================================\n&quot;);
    printf(&quot;插入完成\n&quot;);
    printf(&quot;===========================================\n&quot;);

    
    [list outPut:list];
    printf(&quot;===========================================\n&quot;);
    printf(&quot;删除完成\n&quot;);
    printf(&quot;===========================================\n&quot;);
}
return 0; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/%E9%BE%99%E5%B0%91/first-link&quot;&gt;objective-c算法详解(一、链表)&lt;/a&gt; was originally published by LastDay at &lt;a href=&quot;http://localhost:4000&quot;&gt;LastDay的博客&lt;/a&gt; on October 15, 2015.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[IP协议的那些事（总结）]]></title>
  <link>http://localhost:4000/theme-setup/first-IP</link>
  <id>http://localhost:4000/theme-setup/first-IP</id>
  <published>2015-10-14T00:00:00-04:00</published>
  <updated>2015-10-14T00:00:00-04:00</updated>
  <author>
    <name>LastDay</name>
    <uri>http://localhost:4000</uri>
    <email>lastdays1122@icloud.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;iptcp&quot;&gt;IP协议是TCP协议栈中的核心协议，也是网络编程的基础之一。&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;网络层概述&lt;/h2&gt;

&lt;h3 id=&quot;ip&quot;&gt;IP服务特点:&lt;/h3&gt;
&lt;p&gt;IP协议为上层协议提供无状态，无连接，不可靠的服务。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;无状态：IP通信双方不同步状态传输信息，因此所有IP数据报的发送和接收都是相互独立的，这样也就造成了它无法处理乱序，重复的IP数据报。相对于面向连接而设定的，例如TCP协议，它能够自己处理乱序，重复的报文段。他递交给上层的内容绝对是有序的正确的。但是IP协议的状态也是有优点的，它简单高效，因为我们无需为保证它的状态而分配一些内核数据结构。&lt;/li&gt;
  &lt;li&gt;无连接：通信双方都不长久的维持对方的任何信息，那么就需要上层协议去指定传输的IP地址。&lt;/li&gt;
  &lt;li&gt;不可靠服务：不可靠指的是IP协议不能保证IP数据报完整并且准确的到达接收端。因此使用IP的上层协议需要自己做数据确认，超时重传等可靠传输机制。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;h3 id=&quot;ipv4&quot;&gt;IPv4头部结构:&lt;/h3&gt;

&lt;p&gt;图一：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150809211053157&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;IPv4头部结构包含20个字节。另外最多包含40个选项字节。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;4位版本号：指定IP协议的版本&lt;/li&gt;
  &lt;li&gt;4位头部长度：标识有多少个四字节。&lt;/li&gt;
  &lt;li&gt;8位服务类型（TOS）：包括一个3位的优先权字段（现在已经被忽律），4位TOS字段（最小延时，最大吞吐量，最高可靠性，最小费用），1位保留字段。以上信息决定了IP协议的可弹性。&lt;/li&gt;
  &lt;li&gt;16位总长度（字节数）：整个IP数据报的长度。就是说IP数据报的最大程度就是2^16－1。因为MTU的限制。最大传输不可能达到这个值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;＝＝＝＝＝＝分片传输实现原理＝＝＝＝＝＝＝＝＝&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;16位标识别：唯一标识主机发送的每一个数据报。初始值有系统随机生成。每发送一个数据报，该值就＋1.因此同一个数据报的分片都具有相同的标识值&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3位标志：&lt;/p&gt;

    &lt;p&gt;（1）第一位是有保留的&lt;/p&gt;

    &lt;p&gt;（2）第二位表示禁止分片（如果对这位进行了设置，IP模块将不会对数据报进行分片，所以可以想象一下我们刚才提到的，如果这个数据报的长度超过MTU，这段数据报就会被丢弃，返回ICMP差错报文）&lt;/p&gt;

    &lt;p&gt;（3）第三位表示等多分片（除了IP数据报的最后一个分片外，其他分片都设置为1）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;13位偏移：是分片相对原始IP数据报开始处的偏移。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这三个字段协同工作行形成了IP分段的功能。&lt;/p&gt;

&lt;p&gt;＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;8位生存时间（TTL）：它是数据报到达目的地前允许经过的路由跳数。在发送过程中，每经过一个路由，该值就减1.当TTL位0时，路由器会丢弃这个数据报，返回ICMP差错报文。它可以防止数据陷入路由循环。&lt;/li&gt;
  &lt;li&gt;8位协议涌来区分上层协议。ICMP位1，TCP为6，UDP位17&lt;/li&gt;
  &lt;li&gt;16位头部校验和：它是由发送端进行填充。接收端对其进行CRC校验算法，来检验头信息在传输过程中是否被损坏。&lt;/li&gt;
  &lt;li&gt;32位原端IP：表示发送端IP&lt;/li&gt;
  &lt;li&gt;32位目的IP：表示接受端IP&lt;/li&gt;
  &lt;li&gt;IPv4头部可变长的选项部分，最多包含401个字节，可选的IP选项包括：（1）纪录路由，（2）时间戳，（3）松散源路由选择，（4）严格路由选择   （这些的介绍会在以后进行分享）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IP协议是TCP协议栈中的核心协议，也是网络编程的基础之一。
我们接着在&lt;a href=&quot;http://blog.csdn.net/lastdays_l/article/details/47395921&quot;&gt;IP协议解读（一）&lt;/a&gt;继续学习&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;网络层作用&lt;/h2&gt;

&lt;h3 id=&quot;ip-1&quot;&gt;IP分片：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IP数据报的长度超过帧的MTU时，将会被分片传输。分片可能发生在发送端，也可能发生在中转路由器上，并且可能在传输过程中被多次分片。最终会在接收器上被IP模块重新组装。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在&lt;a href=&quot;http://blog.csdn.net/lastdays_l/article/details/47395921&quot;&gt;IP协议解读（一）&lt;/a&gt;中讲述了16位数据报标识、3位的标识，13位的片偏移给分片和重组提供了足够的信息。一个IP数据报的每个分片都具有自己的头部。他们具有相同的标识值，但具有不同的片偏移。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以太网的MTU位1500字节，因此它能携带的最大字节量位1480字节，因为IP头部包含20个字节。假如我们使用以太网帧传输用IP数据报封装的1481个字节的ICMP数据报。这个时候&amp;gt;1480字节，所以就会出现分片现象&lt;/p&gt;

    &lt;p&gt;###那么1481个字节的数据+20字节的IP头部=1501字节的IP数据报=IP分片（1500字节）+IP分片（21字节） 
  结构如图所示：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150811121717075&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从以上的图片我可以分析出来，ICMP头部的8个字节被分配到第一个分片中，其中1472字节的ICMP的数据也被分配到第一个分片中，这样IP头+ICMP头部结构+部分ICMP数据组成了最大的IP分片（1500字节），剩下的一个个字节的ICMP数据被分配到第二个IP分片中（21字节）&lt;/p&gt;

&lt;p&gt;下面我们用实例演示：&lt;/p&gt;

&lt;p&gt;我们使用ping命令指定每次发送的大小位1473个字节&lt;/p&gt;

&lt;p&gt;```
ping www.baidu.com -s 1473&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150811121838596&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们使用tcpdump命令抓取ping过程中的icmp数据包&lt;/p&gt;

&lt;p&gt;```
tcpdump -ntv -i eth0 icmp&lt;/p&gt;

&lt;p&gt;```
&lt;img src=&quot;http://img.blog.csdn.net/20150811121920417&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;===============查看分析抓去结果=====================&lt;/p&gt;

&lt;p&gt;结果如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150811122731873&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图片中我们可以看出，前两个数据报的ip分片id（标识值）都是27300，说明这两个是同一个分片，第一个分片的offset（偏移值）为0，第二个分片的offset（偏移值）为0位1480.根据信息显示，第一个ICMP占1480个字节，第二个长度为21.&lt;/p&gt;

&lt;h3 id=&quot;ip-2&quot;&gt;IP路由选择机制：&lt;/h3&gt;

&lt;p&gt;路由选择是IP协议的核心任务，指定了发送数据报到目标路径的途径&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150811122637878&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当IP模块接受到来自网络驱动程序发来的IP数据报时，首先对头部进行CRC校验，确定这个数据包在传输过程中没有被损坏。&lt;/li&gt;
  &lt;li&gt;如果发现IP头部信息中带有&lt;strong&gt;源站选路&lt;/strong&gt;选项，那么IP模块调用数据报转发子模块处理这个数据报。&lt;/li&gt;
  &lt;li&gt;如果这个IP数据报头部结构中目标IP地址是本机的IP地址或是广播地址，就是说明这个数据报是发送给本机的IP模块就必须根据数据报的头部结构协议字段将它发给哪个上层应用。&lt;/li&gt;
  &lt;li&gt;如果IP模块发现这个数据报不是发送给本机的，同样也掉中转发子模块处理这个数据报，转发子模块首先需要检验这个数据报是否被允许转发。不允许的话这个数据报就会被丢弃。允许的话数据报转发子模块将对这个数据报进行一系列的操作，然后将它交给IP数据报输出子模块。&lt;/li&gt;
  &lt;li&gt;其实呢，IP数据报应该发送到哪一个吓一跳路由，经过哪个网卡来发送，是&lt;strong&gt;计算吓一跳&lt;/strong&gt;路由这个模块完成的。&lt;/li&gt;
  &lt;li&gt;IP模块实现数据报路由的核心数据结构就是&lt;strong&gt;路由表&lt;/strong&gt;，这个表是按照目的IP进行分类。&lt;/li&gt;
  &lt;li&gt;IP输出队列中是所有等待发出的数据报。&lt;/li&gt;
  &lt;li&gt;虚线箭头是整个路由表的更新过程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IP路由选择过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;查找完全匹配的主机地址，如果找到就是用该路由项，如果未找到，进入下一个步骤&lt;/li&gt;
  &lt;li&gt;查找相同网络ID的网络IP地址，如果找到就是用该路由项，如果未找到，进入下第三个步骤&lt;/li&gt;
  &lt;li&gt;选择默认路由项，这意味着下一跳的路由地址是网关&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip-3&quot;&gt;IP转发过程：&lt;/h3&gt;

&lt;p&gt;路由器转发模块的执行过程如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;检查数据报头部的TTL值（TTL为0丢弃这个数据报）。&lt;/li&gt;
  &lt;li&gt;查看数据包的严格源路由的选择选项，如果被设置，检测数据报的目的IP地址是否和本机的某个IP地址相同，如果不是，发送一个ICMP差错报文。&lt;/li&gt;
  &lt;li&gt;给源端发送一个ICMP重定向报文（下一个文章分享）。&lt;/li&gt;
  &lt;li&gt;将TTL值减1&lt;/li&gt;
  &lt;li&gt;处理IP头部选项&lt;/li&gt;
  &lt;li&gt;如果有必要，执行IP分片操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;路由表更新：&lt;/h3&gt;

&lt;p&gt;路由表必须具备更新，反应网络中的连接的变化，这样IP模块才能准确，高效的转发数据报。&lt;/p&gt;

&lt;p&gt;进行实例演示。&lt;/p&gt;

&lt;p&gt;Linux下使用明route命令查看当前主机下的路由表信息。
&lt;img src=&quot;http://img.blog.csdn.net/20150811122852036&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一行表示子系统下的默认路由&lt;/p&gt;

&lt;p&gt;使用route命令添加路由表&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150811123013217&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;删除对应项&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150811123030527&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;删除默认路由项，这样做的后果就是无法访问因特网。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150811123044978&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;今天我们来介绍网络层中的ICMP协议&lt;/p&gt;

&lt;h2 id=&quot;icmp&quot;&gt;ICMP报文格式&lt;/h2&gt;

&lt;p&gt;图一：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150812131618110&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图片上我们可以分析出，前三位的字段都是固定的，8位类型字段，8位代码字段，16位校验和字段。其他字段因ICMP报文类型不同而不同。8位类型和8位代码一起决定了报文的类型。&lt;/p&gt;

&lt;h2 id=&quot;icmp-1&quot;&gt;ICMP查询格式&lt;/h2&gt;

&lt;h3 id=&quot;icmp4&quot;&gt;ICMP查询报文共有4种&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;回送请求和回答：由主机和路由器向一个特定的主机和路由器发送询问，收到请求的主机必须给源主机发送回送应答报文，用来测试目标主机是否可达以及了解其他状态&lt;/li&gt;
  &lt;li&gt;时间戳请求和回答：它允许系统向另一个系统查询当前的时间，该ICMP的好处是他提供了毫秒级的分辨率。&lt;/li&gt;
  &lt;li&gt;掩码地址请求和回答：主机使用ICMP地址掩码地址请求报文可以向子网掩码服务器得到某个接口的地址掩码。系统广播他的ICMP请求报文。&lt;/li&gt;
  &lt;li&gt;路由器询问和通过报文：主机使用ICMP路由器询问连接在本网络上的路由器是否正常工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;icmp-2&quot;&gt;ICMP差错报文&lt;/h2&gt;

&lt;h3 id=&quot;icmp5&quot;&gt;ICMP差错报文共有5种：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;终点不可达：网络不可达，主机不可达，协议不可达，端口不可达，源路由失败&lt;/li&gt;
  &lt;li&gt;源站抑制：当路由器或主机因为拥塞丢弃数据包时，就向源站发送源站抑制报文，使源站知道应当将发送数据报的速度放慢。&lt;/li&gt;
  &lt;li&gt;时间超过：路由器收到生存时间为0的数据报时，除丢弃该数据报外还要向源站发送时间超时报文&lt;/li&gt;
  &lt;li&gt;参数问题差：当路由器的目的主机收到的数据报首部中的字段不正确的时候，丢弃该数据报，同时向源地址发送ICMP参数问题报文。&lt;/li&gt;
  &lt;li&gt;重定向报文：路由器将改变路由报文，将发送给主机，让主机知道，下一次的数据报应该发送给另一个路由器。&lt;/li&gt;
&lt;/ul&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/theme-setup/first-IP&quot;&gt;IP协议的那些事（总结）&lt;/a&gt; was originally published by LastDay at &lt;a href=&quot;http://localhost:4000&quot;&gt;LastDay的博客&lt;/a&gt; on October 14, 2015.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[翻译社]]></title>
  <link>http://localhost:4000/theme-setup/first-qq</link>
  <id>http://localhost:4000/theme-setup/first-qq</id>
  <published>2015-10-11T00:00:00-04:00</published>
  <updated>2015-10-11T00:00:00-04:00</updated>
  <author>
    <name>LastDay</name>
    <uri>http://localhost:4000</uri>
    <email>lastdays1122@icloud.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;core-graphics-tutorial-part-3-patterns-and-playgrounds&quot;&gt;Core Graphics Tutorial Part 3: Patterns and Playgrounds&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Update 04/15/2015:&lt;/strong&gt;Updated for Xcode 6.3 and Swift 1.2&lt;/p&gt;

&lt;p&gt;Welcome back to the third and final part of the Core Graphics tutorial series! Flo, your water drinking tracking app, is ready for its final evolution, which you’ll make happen with Core Graphics.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&quot;http://www.raywenderlich.com/90690/modern-core-graphics-with-swift-part-1&quot;&gt;part one&lt;/a&gt;, you drew three custom-shaped controls with UIKit. Then in the &lt;a href=&quot;http://www.raywenderlich.com/90693/modern-core-graphics-with-swift-part-2&quot;&gt;part two&lt;/a&gt;, you created a graph view to show the user’s water consumption over a week, and you explored transforming the context transformation matrix (CTM).&lt;/p&gt;

&lt;p&gt;In this third and final part, you’ll take &lt;strong&gt;Flo&lt;/strong&gt; to its 
final form. Specifically, you’ll:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Create a repeating pattern for the background.&lt;/li&gt;
  &lt;li&gt;Draw a medal from start to finish to award the users for successfully drinking eight glasses of water a day.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you don’t have it already, &lt;a href=&quot;http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part2-6.3.zip&quot;&gt;download a copy of the &lt;strong&gt;Flo&lt;/strong&gt; project&lt;/a&gt; from the second part of this series.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/FinalApp-192x320.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;欢迎回到Core Graphics 教学系列的第三部分和最后一部分！Flo，你的water drinking tracking app将使用Core Graphics 进行最终的改进。&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;[part one](http://www.raywenderlich.com/90690/modern-core-graphics-with-swift-part-1)&quot;&gt;在第一部分&lt;/a&gt;，你画了三个自定义形状的控件以及UIKit,&lt;a href=&quot;http://www.raywenderlich.com/90693/modern-core-graphics-with-swift-part-2&quot;&gt;在第二部分&lt;/a&gt;你创建了一个视图用来显示用户在过去一周的喝水量，并且研究了transforming the context transformation matrix (CTM)&lt;/p&gt;

&lt;p&gt;在这第三部分和最后一部分，你将使用它的最终格式，特别的是你将使用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建一个重复的图案背景&lt;/li&gt;
  &lt;li&gt;从开始到结束，为成功每天喝掉8杯水的用户画一枚奖章&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你不想做，从本系列的第二部分下载&lt;a href=&quot;http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part2-6.3.zip&quot;&gt;&lt;strong&gt;Flo工程&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;background-repeating-pattern-&quot;&gt;Background Repeating Pattern 背景重复模式&lt;/h2&gt;

&lt;p&gt;Your mission in this section is to use UIKit’s pattern methods to create this background pattern:&lt;/p&gt;

&lt;p&gt;你在这部分的任务是使用UIKit的方式创建这个背景图案：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-FinalBackground-300x500.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Note: If you need to optimize for speed, then work through
Core Graphics Tutorial: Patterns which demonstrates a basic 
way to create patterns with Objective-C and Core Graphics. 
For most purposes, like when the background is only drawn 
once, UIKit’s easier wrapper methods should be acceptable.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：如果你需要对速度进行优化，接下来的工作就是通过&lt;a href=&quot;http://www.raywenderlich.com/33496/core-graphics-tutorial-patterns&quot;&gt;Core Graphics Tutorial&lt;/a&gt;：
演示一个基本的方法去创建一个格局使用Object－c和Core Graphics.针对实用性问题，
当背景仅被描绘一次，使用UIKit封装好的简易方法应该是可以被接受的&lt;/p&gt;

&lt;p&gt;Go to &lt;strong&gt;File\New\File…&lt;/strong&gt;and select the iOS &lt;strong&gt;iOS\Source\Cocoa Touch Class&lt;/strong&gt;template to create a class called &lt;strong&gt;BackgroundView&lt;/strong&gt; with a subclass of UIView. Click Next and then Create.&lt;/p&gt;

&lt;p&gt;Go to &lt;strong&gt;Main.storyboard&lt;/strong&gt;, select the main view of ViewController, and change the class to &lt;strong&gt;BackgroundView&lt;/strong&gt; in the &lt;strong&gt;Identity Inspector.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;点击&lt;strong&gt;File\New\File…&lt;/strong&gt;并且选择IOS &lt;strong&gt;iOS\Source\Cocoa Touch Class&lt;/strong&gt; 模版创建一个累起名为&lt;strong&gt;BackgroundView&lt;/strong&gt;的UIView。点击下一步然后创建&lt;/p&gt;

&lt;p&gt;进入&lt;strong&gt;Main.storyboard&lt;/strong&gt;，在 &lt;strong&gt;Identity Inspector&lt;/strong&gt;选择ViewController主界面，改变为&lt;strong&gt;BackgroundView&lt;/strong&gt;
&lt;img src=&quot;http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-BackgroundViewStoryboard3-480x187.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Set up &lt;strong&gt;BackgroundView.swift&lt;/strong&gt; and &lt;strong&gt;Main.storyboard&lt;/strong&gt; so they are side-by-side, using the &lt;strong&gt;Assistant Editor&lt;/strong&gt;.
Replace the code in &lt;strong&gt;BackgroundView.swift&lt;/strong&gt; with:&lt;/p&gt;

&lt;p&gt;建立&lt;strong&gt;BackgroundView.swift&lt;/strong&gt;和&lt;strong&gt;Main.storyboard&lt;/strong&gt;，所以他们是并排的，使用&lt;strong&gt;Assistant Editor&lt;/strong&gt;
替换&lt;strong&gt;BackgroundView.swift&lt;/strong&gt;的代码：&lt;/p&gt;

&lt;p&gt;```
import UIKit&lt;/p&gt;

&lt;p&gt;@IBDesignable&lt;/p&gt;

&lt;p&gt;class BackgroundView: UIView {&lt;/p&gt;

&lt;p&gt;//1 
  @IBInspectable var lightColor: UIColor = UIColor.orangeColor()
  @IBInspectable var darkColor: UIColor = UIColor.yellowColor()
  @IBInspectable var patternSize:CGFloat = 200&lt;/p&gt;

&lt;p&gt;override func drawRect(rect: CGRect) {
    //2
    let context = UIGraphicsGetCurrentContext()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//3
CGContextSetFillColorWithColor(context, darkColor.CGColor)
 
//4
CGContextFillRect(context, rect)   } } ``` The background view of your storyboard should now be yellow. More detail on the above code:
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;ightColor&lt;/strong&gt; and &lt;strong&gt;darkColor&lt;/strong&gt; have &lt;strong&gt;@IBInspectable&lt;/strong&gt; attributes so it’s easier to configure background colors later on. You’re using orange and yellow as temporary colors, just so you can see what’s happening. &lt;strong&gt;patternSize&lt;/strong&gt;controls the size of the repeating pattern. It’s initially set to large, so it’s easy to see what’s happening.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;UIGraphicsGetCurrentContext()&lt;/strong&gt; gives you the view’s context and is also where &lt;strong&gt;drawRect(_:)&lt;/strong&gt;draws.&lt;/li&gt;
  &lt;li&gt;Use the Core Graphics method &lt;strong&gt;CGContextSetFillColorWithColor()&lt;/strong&gt; to set the current fill color of the context. Notice that you need to use &lt;strong&gt;CGColor&lt;/strong&gt;, a property of &lt;strong&gt;darkColor&lt;/strong&gt; when using Core Graphics.&lt;/li&gt;
  &lt;li&gt;Instead of setting up a rectangular path,&lt;strong&gt;CGContextFillRect()&lt;/strong&gt; fills the entire context with the current fill color.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You’re now going to draw these three orange triangles using &lt;strong&gt;UIBezierPath()&lt;/strong&gt;. The numbers correspond to the points in the following code:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;ightColor&lt;/strong&gt;和&lt;strong&gt;darkColor&lt;/strong&gt;拥有&lt;strong&gt;@IBInspectable&lt;/strong&gt;属性，所以他更容易去配置背景颜色。你使用橙色和黄色作为临时色，你可以看看发生了什么。&lt;strong&gt;patternSize&lt;/strong&gt;控件控制着重复形式的大小。它的初始值设置的大一些，所以更容易看清发生了什么。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;UIGraphicsGetCurrentContext()&lt;/strong&gt;让你了解上下部分哪些&lt;strong&gt;drawRect(_:)&lt;/strong&gt;被描述。&lt;/li&gt;
  &lt;li&gt;使用Core Graphics的方法&lt;strong&gt;CGContextSetFillColorWithColor()&lt;/strong&gt; 去设置当前上下文的填充色。注意当你使用Core Graphics需要用到&lt;strong&gt;darkColor&lt;/strong&gt;的一个属性&lt;/li&gt;
  &lt;li&gt;而不是建立一个矩形路径，&lt;strong&gt;CGContextFillRect()&lt;/strong&gt;使用当前填充色填充当前上下文的整个背景&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你现在需要使用&lt;strong&gt;UIBezierPath()&lt;/strong&gt;画三个橙色的三角形。数字对应一下代码中的点
&lt;img src=&quot;http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-GridPattern.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Still in &lt;strong&gt;BackgroundView.swift&lt;/strong&gt;, add this code to the end of &lt;strong&gt;drawRect(&lt;em&gt;:)**:
仍然在**BackgroundView.swift**中操作，在 **drawRect(&lt;/em&gt;:)&lt;/strong&gt;末尾添加如下代码：&lt;/p&gt;

&lt;p&gt;```
let drawSize = CGSize(width: patternSize, height: patternSize)&lt;/p&gt;

&lt;p&gt;//insert code here&lt;/p&gt;

&lt;p&gt;let trianglePath = UIBezierPath()
//1
trianglePath.moveToPoint(CGPoint(x:drawSize.width/2, 
                                 y:0)) 
//2
trianglePath.addLineToPoint(CGPoint(x:0, 
                                    y:drawSize.height/2)) 
//3
trianglePath.addLineToPoint(CGPoint(x:drawSize.width, 
                                    y:drawSize.height/2))&lt;/p&gt;

&lt;p&gt;//4
trianglePath.moveToPoint(CGPoint(x: 0, 
                                 y: drawSize.height/2)) 
//5
trianglePath.addLineToPoint(CGPoint(x: drawSize.width/2, 
                                    y: drawSize.height)) 
//6
trianglePath.addLineToPoint(CGPoint(x: 0, 
                                    y: drawSize.height))&lt;/p&gt;

&lt;p&gt;//7
trianglePath.moveToPoint(CGPoint(x: drawSize.width, 
                                 y: drawSize.height/2)) 
//8
trianglePath.addLineToPoint(CGPoint(x:drawSize.width/2, 
                                    y:drawSize.height)) 
//9
trianglePath.addLineToPoint(CGPoint(x: drawSize.width, 
                                    y: drawSize.height))&lt;/p&gt;

&lt;p&gt;lightColor.setFill()
trianglePath.fill()&lt;/p&gt;

&lt;p&gt;```
Notice how you use one path to draw three triangles. &lt;strong&gt;moveToPoint(_:)&lt;/strong&gt; is just like lifting your pen from the paper when you’re drawing and moving it to a new spot.&lt;/p&gt;

&lt;p&gt;注意你如何使用一个路径画三个三角形，就像在纸上抬起你的笔从一个地方绘制和移动到另一个地方&lt;/p&gt;

&lt;p&gt;Your storyboard should now have an orange and yellow image at the top left of your background view.&lt;/p&gt;

&lt;p&gt;你的storyboard现在应该有一个橙色和黄的的图像在你背景的左上方&lt;/p&gt;

&lt;p&gt;So far, you’ve drawn directly into the view’s drawing context. To be able to repeat this pattern, you need to create an image outside of the context, and then use that image as a pattern in the context.&lt;/p&gt;

&lt;p&gt;到目前为止，你已经直接描绘了视图上下部分，可以重复此模式，你需要创建一个外部图像，然后使用这个图片作为背景图案&lt;/p&gt;

&lt;p&gt;Find the following. It’s close to the top of drawRect(_:), but after:
找到一一下部分，它接近顶部，接着&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
et drawSize = CGSize(width: patternSize, height: patternSize)
&lt;/code&gt;
Add the following code where it conveniently says &lt;strong&gt;Insert code here&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;然后插入一下代码&lt;/p&gt;

&lt;p&gt;```
UIGraphicsBeginImageContextWithOptions(drawSize, true, 0.0)
let drawingContext = UIGraphicsGetCurrentContext()&lt;/p&gt;

&lt;p&gt;//set the fill color for the new context
darkColor.setFill()
CGContextFillRect(drawingContext,
      CGRectMake(0, 0, drawSize.width, drawSize.height))
```&lt;/p&gt;

&lt;p&gt;Hey! Those orange triangles disappeared from the storyboard. Where’d they go?
嘿，那些橘黄色三角形从面板中消失了，他们去哪了？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UIGraphicsBeginImageContextWithOptions()&lt;/strong&gt;creates a new context and sets it as the current drawing context, so you’re now drawing into this new context. The parameters of this method are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The size of the context.&lt;/li&gt;
  &lt;li&gt;Whether the context is opaque — if you need transparency, then this needs to be false.&lt;/li&gt;
  &lt;li&gt;The scale of the context. If you’re drawing to a retina screen, this should be 2.0, and if to an iPhone 6 Plus, it should be 3.0. However, this uses 0.0, which ensures the correct scale for the device is automatically applied.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;UIGraphicsBeginImageContextWithOptions()&lt;/strong&gt;创建了一个新的视图，并且将其设置为当前的绘图。刚方法的参数为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;context大小&lt;/li&gt;
  &lt;li&gt;背景是否透明— 如果你需要透明的, 这里设置为false.&lt;/li&gt;
  &lt;li&gt;context的大小. 如果你话一个视网膜屏幕, 这里应该设置为2, 对于 iPhone 6 Plus, 他应该为3.0. 然而这里使用0将自动适配屏幕&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then you used &lt;strong&gt;UIGraphicsGetCurrentContext()&lt;/strong&gt; to get a reference to this new context.&lt;/p&gt;

&lt;p&gt;然后使用 &lt;strong&gt;UIGraphicsGetCurrentContext()&lt;/strong&gt;得到这个新的context&lt;/p&gt;

&lt;p&gt;You then filled the new context with yellow. You could have let the original background show through by setting the context opacity to false, but it’s faster to draw opaque contexts than it is to draw transparent, and that’s argument enough to go opaque.&lt;/p&gt;

&lt;p&gt;将这个新的context设置为黄色。你可以通过设这context的属性opacity为false让原来的背景色显示。&lt;/p&gt;

&lt;p&gt;Add this code to the end of &lt;strong&gt;drawRect(&lt;em&gt;:)**:
在**drawRect(&lt;/em&gt;:)&lt;/strong&gt;添加一下代码&lt;/p&gt;

&lt;p&gt;```
let image = UIGraphicsGetImageFromCurrentImageContext()
UIGraphicsEndImageContext()&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;This extracts a UIImage from the current context. When you end the current context with &lt;strong&gt;UIGraphicsEndImageContext()&lt;/strong&gt;, the drawing context reverts to the view’s context, so any further drawing in &lt;strong&gt;drawRect(_:)&lt;/strong&gt; happens in the view.&lt;/p&gt;

&lt;p&gt;在当前的context提取。当你使用&lt;strong&gt;UIGraphicsEndImageContext()&lt;/strong&gt;结束context，描绘的context还原视图的context，所以在任何未来在&lt;strong&gt;drawRect(_:)&lt;/strong&gt; 中的的绘图都发生在view&lt;/p&gt;

&lt;p&gt;To draw the image as a repeated pattern, add this code to the end of drawRect(_:):&lt;/p&gt;

&lt;p&gt;把图像作为重复图案，在drawRect(_:)末尾添加代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
UIColor(patternImage: image).setFill()
CGContextFillRect(context, rect)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This creates a new UIColor by using an image as a color instead of a solid color.&lt;/p&gt;

&lt;p&gt;创建了一个新的UIColor通过使用图像作为背景颜色，而不是固定色。&lt;/p&gt;

&lt;p&gt;Build and run the app. You should now have a rather bright background for your app. :&lt;/p&gt;

&lt;p&gt;构建并且运行app，你现在的app应该有一个明亮的背景：
&lt;img src=&quot;http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/3-BoldBackground2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Go to Main.storyboard, select the background view, and in the Attributes Inspector change the @IBInspectable values to the following:&lt;/p&gt;

&lt;p&gt;去Main.storyboard，选择background view，并且在Attributes Inspector改变IBInspectable属性的值为以下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Light Color: RGB(255, 255, 242)&lt;/li&gt;
  &lt;li&gt;Dark Color: RGB(223, 255, 247)&lt;/li&gt;
  &lt;li&gt;Pattern Size: 30
&lt;img src=&quot;http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-BackgroundColors2-473x320.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Experiment a little more with drawing background patterns. See if you can get a polka dot pattern as a background instead of the triangles.&lt;/p&gt;

&lt;p&gt;尝试去画一些背景图案，看看能不能得到一个园作为背景图案，而不是三角形。&lt;/p&gt;

&lt;p&gt;And of course, you can substitute your own non-vector images as repeating patterns.&lt;/p&gt;

&lt;p&gt;当然，你可以使用自己的非矢量图作为背景图案&lt;/p&gt;

&lt;h2 id=&quot;drawing-images-&quot;&gt;Drawing Images 绘制图像&lt;/h2&gt;

&lt;p&gt;In the final stretch of this tutorial, you’ll make a medal to handsomely reward users for drinking enough water. This medal will appear when the counter reaches the target of eight glasses.&lt;/p&gt;

&lt;p&gt;在本教程的最后阶段，你将为和足够水的人送上一个奖牌，当计数器纪录的数量达到8杯的时候奖牌将出现&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/3-MedalFinal.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I know that’s certainly not a museum-worthy piece of art, so please know that I won’t be offended if you improve it, or even take it to the next level by draw a trophy instead of a medal. ;]&lt;/p&gt;

&lt;p&gt;我知道那并会像博物馆里的一件艺术品，所以请你知道，如果你提升它，我并不会生气，甚至你可以通过画一个奖杯而不是奖牌&lt;/p&gt;

&lt;p&gt;Instead of using &lt;strong&gt;@IBDesignable&lt;/strong&gt;, you’ll draw it in a &lt;strong&gt;Swift Playground&lt;/strong&gt;, and then copy the code to a &lt;strong&gt;UIImageView&lt;/strong&gt; subclass. Though interactive storyboards are often useful, they have limitations; they only draw simple code, and storyboards often time out when you create complex designs.&lt;/p&gt;

&lt;p&gt;你描绘它将使用swift，然后复制这段代码到&lt;strong&gt;UIImageView&lt;/strong&gt;子集。虽然与storyboards互动通长是很有用的，但他们有局限性。他们仅能描绘简单的代码，storyboards通长很耗时间当你创建一个复杂的设计。&lt;/p&gt;

&lt;p&gt;In this particular case, you only need to draw the image once when the user drinks eight glasses of water. If the user never reaches the target, there’s no need to make a medal.&lt;/p&gt;

&lt;p&gt;在这种情况下，当用户喝满八杯水的时候仅需要画一个图像。如果用户从来没有到达到过目标，根本不需要绘制奖牌。&lt;/p&gt;

&lt;p&gt;Once drawn, it also doesn’t need to be redrawn with drawRect(_:) and setNeedsDisplay().&lt;/p&gt;

&lt;p&gt;一旦绘制，他也不需要使用drawRect(_:)和setNeedsDisplay().进行重绘。&lt;/p&gt;

&lt;p&gt;Time to put the brush to the canvas. First return Xcode to single viewing, rather than side-by-side, by clicking the Standard Editor icon:&lt;/p&gt;

&lt;p&gt;时间画笔。首先返回Xcode界面点击编辑图标，操作并不是并行的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-StandardEditor.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Go to &lt;strong&gt;File\New\File…&lt;/strong&gt; and choose the iOS Playground template. Click Next, name the playground MedalDrawing and then click Create.&lt;/p&gt;

&lt;p&gt;进入 &lt;strong&gt;File\New\File…&lt;/strong&gt;并且选择IOS Playground 模版。点击 Next 命名为 playground 为MedalDrawing 然后点击Create&lt;/p&gt;

&lt;p&gt;Replace the playground code with:
添加一下代码：&lt;/p&gt;

&lt;p&gt;```
import UIKit&lt;/p&gt;

&lt;p&gt;let size = CGSize(width: 120, height: 200)&lt;/p&gt;

&lt;p&gt;UIGraphicsBeginImageContextWithOptions(size, false, 0.0)
let context = UIGraphicsGetCurrentContext()&lt;/p&gt;

&lt;p&gt;//This code must always be at the end of the playground
let image = UIGraphicsGetImageFromCurrentImageContext()
UIGraphicsEndImageContext()
```
This creates a drawing context, just as you did for the patterned image.&lt;/p&gt;

&lt;p&gt;创建描绘一个context，就像你做了一个重叠图片&lt;/p&gt;

&lt;p&gt;Take note of these last two lines; you always need them at the bottom of the playground so you can preview the image in the playground.&lt;/p&gt;

&lt;p&gt;注意最后两行。你总是需要他们在playground底部，所以你可以预览palyground的图片。&lt;/p&gt;

&lt;p&gt;Next, in the gray results column click the + button to the right of this code:&lt;/p&gt;

&lt;p&gt;其次在灰色的结果栏中单击代码右边的＋按钮：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/ShowFinishedImage.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;this will place a preview image underneath the code. The image will update with every change that you make to the code.&lt;/p&gt;

&lt;p&gt;这将在代码的地步预览你图像。图像将根据你代码的每次更新而更新。&lt;/p&gt;

&lt;p&gt;It’s often best to do a sketch to wrap your head around the order you’ll need to draw the elements — look at the “masterpiece” I made while conceptualizing this tutorial:&lt;/p&gt;

&lt;p&gt;我么最好做一个草图，把头命令藏在你需绘制的图像中，看看“masterpiece”我构思的教程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-Sketch.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is the order to draw the medal:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The back ribbon (red)&lt;/li&gt;
  &lt;li&gt;The medallion (gold gradient)&lt;/li&gt;
  &lt;li&gt;The clasp (dark gold)&lt;/li&gt;
  &lt;li&gt;The front ribbon (blue)&lt;/li&gt;
  &lt;li&gt;The number 1 (dark gold)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是为了绘制奖牌:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;回丝带（红色）&lt;/li&gt;
  &lt;li&gt;奖章（金梯）&lt;/li&gt;
  &lt;li&gt;扣子（暗金色）&lt;/li&gt;
  &lt;li&gt;前带（蓝色）&lt;/li&gt;
  &lt;li&gt;1号（暗金色）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Remember to keep the last two lines of the playground (where you extract the image from the context at the very end), and add this drawing code to the playground before those lines:&lt;/p&gt;

&lt;p&gt;记住改变playground最后两行（在你最后提取背景图像的地方），并且在这之前添加描绘代码到playground：&lt;/p&gt;

&lt;p&gt;First, set up the non-standard colors you need.
首先设置你要下的非标准颜色。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
//Gold colors
let darkGoldColor = UIColor(red: 0.6, green: 0.5, blue: 0.15, alpha: 1.0)
let midGoldColor = UIColor(red: 0.86, green: 0.73, blue: 0.3, alpha: 1.0)
let lightGoldColor = UIColor(red: 1.0, green: 0.98, blue: 0.9, alpha: 1.0)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This should all look familiar by now. Notice that the colors appear in the right margin of the playground as you declare them.&lt;/p&gt;

&lt;p&gt;由现在看起开这应该很熟悉，当你声明的时候，注意到的颜色出现在palyground右边。&lt;/p&gt;

&lt;p&gt;Add the drawing code for the red part of the ribbon:&lt;/p&gt;

&lt;p&gt;在回丝带部分添加绘图带代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
//Lower Ribbon
var lowerRibbonPath = UIBezierPath()
lowerRibbonPath.moveToPoint(CGPointMake(0, 0))
lowerRibbonPath.addLineToPoint(CGPointMake(40,0))
lowerRibbonPath.addLineToPoint(CGPointMake(78, 70))
lowerRibbonPath.addLineToPoint(CGPointMake(38, 70))
lowerRibbonPath.closePath()
UIColor.redColor().setFill()
lowerRibbonPath.fill()
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Nothing too new here, just creating a path and filling it. You should see the red path appear in the right hand pane.&lt;/p&gt;

&lt;p&gt;没有什么新东西，只是创建一个路径并且填充它。你应该看见红色的路径出现在右侧的窗格中。&lt;/p&gt;

&lt;p&gt;Add the code for the clasp:&lt;/p&gt;

&lt;p&gt;添加扣子描绘代码：&lt;/p&gt;

&lt;p&gt;```
//Clasp&lt;/p&gt;

&lt;p&gt;var claspPath = UIBezierPath(roundedRect: 
                           CGRectMake(36, 62, 43, 20), 
                           cornerRadius: 5)
claspPath.lineWidth = 5
darkGoldColor.setStroke()
claspPath.stroke()
```&lt;/p&gt;

&lt;p&gt;Here you make use of &lt;strong&gt;UIBezierPath(roundedRect:)&lt;/strong&gt; with rounded corners by using the &lt;strong&gt;cornerRadius&lt;/strong&gt; parameter. The clasp should draw in the right pane.&lt;/p&gt;

&lt;p&gt;在这里你将使用 &lt;strong&gt;UIBezierPath(roundedRect:)&lt;/strong&gt; ，圆角半通过使用&lt;strong&gt;cornerRadius&lt;/strong&gt;.
扣子应该在右侧显示。&lt;/p&gt;

&lt;p&gt;Add the code for the medallion:&lt;/p&gt;

&lt;p&gt;添加奖章代码：&lt;/p&gt;

&lt;p&gt;```
//Medallion&lt;/p&gt;

&lt;p&gt;var medallionPath = UIBezierPath(ovalInRect: 
                    CGRect(origin: CGPointMake(8, 72), 
                             size: CGSizeMake(100, 100)))
//CGContextSaveGState(context)
//medallionPath.addClip()
let gradient = CGGradientCreateWithColors(
                      CGColorSpaceCreateDeviceRGB(), 
                      [darkGoldColor.CGColor, 
                       midGoldColor.CGColor, 
                       lightGoldColor.CGColor],
                      [0, 0.51, 1])
CGContextDrawLinearGradient(context,
                            gradient, 
                            CGPointMake(40, 40), 
                            CGPointMake(40,162), 
                             0)
//CGContextRestoreGState(context)
```
Notice the commented out the lines. These are here to temporarily show how the gradient is drawn:&lt;/p&gt;

&lt;p&gt;注意注释部分，这些都是暂时显示梯度用的：
&lt;img src=&quot;http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-SquareGradient.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To put the gradient on a slant, so that it goes from top-left to bottom-right, change the end x coordinate of the gradient. Alter the CGContextDrawLinearGradient() code to:&lt;/p&gt;

&lt;p&gt;把梯度斜着，使它从左上到右下，高变梯度，结束x坐标。改变 &lt;strong&gt;CGContextDrawLinearGradient()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
CGContextDrawLinearGradient(context,
                            gradient, 
                            CGPointMake(40, 40), 
                            CGPointMake(100,160), 
                             0)
&lt;/code&gt; 
&lt;img src=&quot;http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-SkewedGradient.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now uncomment those three lines in the medallion drawing code to create a clipping path to constrain the gradient within the medallion’s circle.&lt;/p&gt;

&lt;p&gt;现在取消徽章那部分的三行注释并且创建一个剪切路径约束在奖章圈的梯度范围内&lt;/p&gt;

&lt;p&gt;Just as you did when drawing the graph in part two, you save the context’s drawing state before adding the clipping path, and restore it after the gradient is drawn so that the context is no longer clipped.&lt;/p&gt;

&lt;p&gt;就像你在绘制图形的第二部分的时候你保存了context之前的剪切路径。恢复后的绘图不会再重叠&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-ClippedGradient.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To draw the solid internal line of the medal, use the medallion’s circle path, but scale it before drawing. Instead of transforming the whole context, you’ll just apply the transform to one path.&lt;/p&gt;

&lt;p&gt;画奖牌的内部线，使用奖牌的圆圈路径，但是在之前规定的区域绘制，而不是转变整个context。你只会应用变换的一个路径。&lt;/p&gt;

&lt;p&gt;Add this code after the medallion drawing code:&lt;/p&gt;

&lt;p&gt;添加奖章绘制代码：&lt;/p&gt;

&lt;p&gt;```
//Create a transform
//Scale it, and translate it right and down
var transform = CGAffineTransformMakeScale(0.8, 0.8)
transform = CGAffineTransformTranslate(transform, 15, 30)&lt;/p&gt;

&lt;p&gt;medallionPath.lineWidth = 2.0&lt;/p&gt;

&lt;p&gt;//apply the transform to the path
medallionPath.applyTransform(transform)
medallionPath.stroke()
```
&lt;img src=&quot;http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-MedalOutline.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This scales the path down to 80 percent of its original size, and then translates the path to keep it centered within the gradient view.&lt;/p&gt;

&lt;p&gt;这个尺寸的路径为原始尺寸的80%，然后将路径保存为中心梯度的内景色。&lt;/p&gt;

&lt;p&gt;Add the upper ribbon drawing code after the internal line code:
添加丝带编码：&lt;/p&gt;

&lt;p&gt;```
//Upper Ribbon&lt;/p&gt;

&lt;p&gt;var upperRibbonPath = UIBezierPath()
upperRibbonPath.moveToPoint(CGPointMake(68, 0))
upperRibbonPath.addLineToPoint(CGPointMake(108, 0))
upperRibbonPath.addLineToPoint(CGPointMake(78, 70))
upperRibbonPath.addLineToPoint(CGPointMake(38, 70))
upperRibbonPath.closePath()&lt;/p&gt;

&lt;p&gt;UIColor.blueColor().setFill()
upperRibbonPath.fill()
```
This is very similar to the code you added for the lower ribbon – making a bezier path and filling it.&lt;/p&gt;

&lt;p&gt;对于添加低位丝带是非常相似的代码，制作一个bezier路径并且填充他。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/3-UpperRibbon.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The last step is to draw the number one on the medal. Add this code after //Upper Ribbon:&lt;/p&gt;

&lt;p&gt;最后一步是在丝带上画 1，代码如下：&lt;/p&gt;

&lt;p&gt;```
//Number One&lt;/p&gt;

&lt;p&gt;//Must be NSString to be able to use drawInRect()
let numberOne = “1”
let numberOneRect = CGRectMake(47, 100, 50, 50)
let font = UIFont(name: “Academy Engraved LET”, size: 60)
let textStyle = NSMutableParagraphStyle.defaultParagraphStyle()
let numberOneAttributes = [
  NSFontAttributeName: font!,
  NSForegroundColorAttributeName: darkGoldColor]
numberOne.drawInRect(numberOneRect, 
                     withAttributes:numberOneAttributes)
```
Here you define a &lt;strong&gt;String&lt;/strong&gt; with text attributes, and draw it into the drawing context using drawInRect(_:).&lt;/p&gt;

&lt;p&gt;在这里你定义了一个字符串属性，并且使用&lt;strong&gt;drawInRect(_:).&lt;/strong&gt;在context进行了重绘&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-NumberOne.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Looking good!&lt;/p&gt;

&lt;p&gt;看上去不错&lt;/p&gt;

&lt;p&gt;You’re getting close, but it’s looking a little two-dimensional — it would be nice to have some drop shadows.&lt;/p&gt;

&lt;p&gt;你已经很接近了，但他看起来有一些二维。它会有一些阴影会更好。&lt;/p&gt;

&lt;h2 id=&quot;shadows-&quot;&gt;Shadows 阴影&lt;/h2&gt;

&lt;p&gt;To create a shadow, you need three elements: the color, the offset (distance and direction of the shadow) and the blur.&lt;/p&gt;

&lt;p&gt;创建一个阴影，需要三个要素：颜色，偏移（阴影的距离和方向）和模糊&lt;/p&gt;

&lt;p&gt;At the top of the playground, after defining the gold colors but just before the //Lower Ribbon, insert this shadow code:&lt;/p&gt;

&lt;p&gt;在 playground 顶部，位于金色之后插入阴影。&lt;/p&gt;

&lt;p&gt;```
//Add Shadow
let shadow:UIColor = UIColor.blackColor().colorWithAlphaComponent(0.80)
let shadowOffset = CGSizeMake(2.0, 2.0)
let shadowBlurRadius: CGFloat = 5&lt;/p&gt;

&lt;p&gt;CGContextSetShadowWithColor(context, 
                            shadowOffset, 
                            shadowBlurRadius, 
                            shadow.CGColor)
```&lt;/p&gt;

&lt;p&gt;Okay, that makes a shadow, but the result is probably not what you pictured. Why is that?&lt;/p&gt;

&lt;p&gt;ok，做了一个阴影后，但结果并不是我们所想象的那样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-MessyShadows.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When you draw an object into the context, this code creates a shadow for each object.&lt;/p&gt;

&lt;p&gt;当你画一个对象为背景，该代码创建了每一个物体的影子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/3-IndividualShadows.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ah-ha! Your medal comprises five objects. No wonder it looks a little fuzzy.
Fortunately, it’s pretty easy to fix. Simply group drawing objects with a transparency layer, and you’ll only draw one shadow for the whole group.&lt;/p&gt;

&lt;p&gt;啊啊啊啊啊，你的奖章，包括五个物体，难怪看起来有点模糊。幸运的是我们更改起来比较容易。简单的透明对象组对象，你只需要对整个对象组绘制一个阴影就可以。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-GroupedShadow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Add the code to make the group after the shadow code. Start with this:&lt;/p&gt;

&lt;p&gt;添加阴影代码从这里开始：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
CGContextBeginTransparencyLayer(context, nil)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When you begin a group you also need to end it, so add this next block at the end of the playground, but still before retrieving the final image:&lt;/p&gt;

&lt;p&gt;当你开始一组，你也需要结束它。所以在playground末端添加这一块。但在这之前仍然需要检索图像。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
CGContextEndTransparencyLayer(context)
&lt;/code&gt;
Now you’ll have a completed medal image with clean, tidy shadows:&lt;/p&gt;

&lt;p&gt;现在你将有一个完整的奖牌图像，整洁的阴影。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/3-MedalFinal.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;image-view-using-core-graphics-image&quot;&gt;Image View Using Core Graphics Image创建一个新的图像视图&lt;/h2&gt;

&lt;p&gt;Create a new file for the Image View.&lt;/p&gt;

&lt;p&gt;Click &lt;strong&gt;File\New\File…&lt;/strong&gt;and choose the &lt;strong&gt;Cocoa Touch Class&lt;/strong&gt; template. Click Next , and name the class MedalView. Make it a subclass of UIImageView, then click Next, then click Create.&lt;/p&gt;

&lt;p&gt;单击&lt;strong&gt;File\New\File…&lt;/strong&gt; ,并且选择 &lt;strong&gt;Cocoa Touch Class&lt;/strong&gt; 模版，单击Next，并且将类命名为
&lt;strong&gt;MedalView&lt;/strong&gt;，子类为&lt;strong&gt;UIImageView&lt;/strong&gt;，然后点击Next，点击Creat&lt;/p&gt;

&lt;p&gt;Go to &lt;strong&gt;Main.storyboard&lt;/strong&gt; and add a &lt;strong&gt;UIImageView&lt;/strong&gt; as a subview of &lt;strong&gt;Counter View&lt;/strong&gt;. Select the UIImageView, and in the &lt;strong&gt;Identity Inspector&lt;/strong&gt; change the class to &lt;strong&gt;MedalView&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;进入&lt;strong&gt;Main.storyboard&lt;/strong&gt;并且添加一个&lt;strong&gt;UIImageView&lt;/strong&gt; &lt;strong&gt;Counter View&lt;/strong&gt;视图。选择UIImageView，并且在&lt;strong&gt;Identity Inspector&lt;/strong&gt;改编为 &lt;strong&gt;MedalView&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-MedalViewClass.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the &lt;strong&gt;Size Inspector&lt;/strong&gt;, give the Image View the coordinates X=76, Y=147, Width=80, and Height=80:&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;Size Inspector&lt;/strong&gt;给视图设置坐标为x=76,y=147,宽度为80,高度为80&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-MedalViewCoordinates.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the &lt;strong&gt;Attributes Inspector&lt;/strong&gt;, change &lt;strong&gt;Image Mode&lt;/strong&gt;to &lt;strong&gt;Aspect Fit&lt;/strong&gt;, so that the image automatically resizes to fit the view.&lt;/p&gt;

&lt;p&gt;在Attributes Inspector，改变&lt;strong&gt;Image Mode&lt;/strong&gt;为&lt;strong&gt;Aspect Fit&lt;/strong&gt;，因此图像自动调整大小适应视图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/3-MedalAspectFit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Go to MedalView.swift and add a method to create the medal:&lt;/p&gt;

&lt;p&gt;去medalview.swift并添加一个方法用来创建的奖章：&lt;/p&gt;

&lt;p&gt;```
func createMedalImage() -&amp;gt; UIImage {
  println(“creating Medal Image”)&lt;/p&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;This makes a log so that you know when the image is being created.
Go to &lt;strong&gt;MedalDrawing&lt;/strong&gt; playground, highlight and copy the entire code except for the initial import UIKit.
Go back to &lt;strong&gt;MedalView.swift&lt;/strong&gt; and paste the playground code into createMedalImage(),
At the end of &lt;strong&gt;createMedalImage()&lt;/strong&gt;, add:&lt;/p&gt;

&lt;p&gt;制作一个日志，纪录当图像被开始创建的时候。&lt;/p&gt;

&lt;p&gt;进入&lt;strong&gt;MedalDrawing&lt;/strong&gt; playground，复制整个代码出了出使导入的UIKit。&lt;/p&gt;

&lt;p&gt;返回&lt;strong&gt;MedalView.swift&lt;/strong&gt;并且粘贴代码到playground代码中的&lt;strong&gt;createMedalImage()&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;createMedalImage()&lt;/strong&gt;尾部添加：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
return image
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;That should squash the compile error.
At the top of the class, add a property to hold the medal image:&lt;/p&gt;

&lt;p&gt;应该编译错误。
在累的顶部添加一个属性保持奖牌图像：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
lazy var medalImage:UIImage = self.createMedalImage()
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Add a method to show the medal:&lt;/p&gt;

&lt;p&gt;添加一个方法去显示奖牌：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
func showMedal(show:Bool) {
  if show {
    image = medalImage
  } else {
    image = nil
  }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Go to &lt;strong&gt;ViewController.swift&lt;/strong&gt; and add an outlet at the top of the class:&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;ViewController.swift&lt;/strong&gt;类顶部添加一个外部接口：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
@IBOutlet weak var medalView: MedalView!
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Go to Main.storyboard and connect the new MedalView to this outlet.&lt;/p&gt;

&lt;p&gt;去Main.storyboard连接一个新MedalView通过这个外部接口&lt;/p&gt;

&lt;p&gt;Go back to &lt;strong&gt;ViewController.swift&lt;/strong&gt; and add this method to the class:&lt;/p&gt;

&lt;p&gt;返回&lt;strong&gt;ViewController.swift&lt;/strong&gt;并且添加这个方法：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
func checkTotal() {
  if counterView.counter &amp;gt;= 8 {
    medalView.showMedal(true)
  } else {
    medalView.showMedal(false)
  }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This shows the medal if you drink enough water for the day.&lt;/p&gt;

&lt;p&gt;如果你今天喝了足够的水，这个奖牌将显示。&lt;/p&gt;

&lt;p&gt;Call this method at both the end of &lt;strong&gt;viewDidLoad()&lt;/strong&gt; and &lt;strong&gt;btnPushButton(_:)&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;在结束的时候调用&lt;strong&gt;viewDidLoad()&lt;/strong&gt; 和 &lt;strong&gt;btnPushButton(_:)&lt;/strong&gt;这两个方法:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
checkTotal()
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Build and run the application. It should look like this:&lt;/p&gt;

&lt;p&gt;构建并运行应用，他应该像这样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/3-CompletedApp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the debug console, you’ll see the creating Medal Image log only outputs when the counter reaches eight and displays the medal, and this is because medalImage uses a lazy declaration.&lt;/p&gt;

&lt;p&gt;在调试控制台，当计数器达到8时，你仅仅能看见奖牌图像日志被输出，这是因为medalImage使用了一个lazy declaration。&lt;/p&gt;

&lt;h2 id=&quot;where-to-go-from-here-&quot;&gt;Where to Go From Here? 何去何从&lt;/h2&gt;

&lt;p&gt;You’ve come a long way in this epic tutorial series. You’ve mastered the basics of Core Graphics: drawing paths, creating patterns and gradients, and transforming the context. To top it all off, you learned how to put it all together in a useful app.&lt;/p&gt;

&lt;p&gt;你已经在这部系列教程中走了很长的路，你已经掌握了Core Graphics的基本知识，创建模式和梯度。并且转换context，最高端的是，你学会了怎么把它添加到app中使用。&lt;/p&gt;

&lt;p&gt;Download the complete version of &lt;a href=&quot;http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part3-6.31.zip&quot;&gt;Flo right here&lt;/a&gt;. This version also includes extra sample data and radial gradients to give the buttons a nice UI touch so they respond when pressed.&lt;/p&gt;

&lt;p&gt;下载完整的版本， &lt;a href=&quot;http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part3-6.31.zip&quot;&gt;Flo right here&lt;/a&gt;.。这个版本也包括提取简单的数据和一个当你按下的时候有很好渐变的效果按钮。&lt;/p&gt;

&lt;p&gt;I hope you enjoyed making Flo, and that you’re now able to make some stunning UIs using nothing but Core Graphics and UIKit! If you have any questions, comments, or you want to hash out how to draw a trophy instead of a medal, please join the forum discussion below.&lt;/p&gt;

&lt;p&gt;我希望你能很享受使用Flo，你现在可以使用Core Graphics和UIKit做一些漂亮的UI！你有任何问题，意见，或者你想讨论如何绘制一个奖杯，而不是一个奖章，请加入论坛讨论下。&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/theme-setup/first-qq&quot;&gt;翻译社&lt;/a&gt; was originally published by LastDay at &lt;a href=&quot;http://localhost:4000&quot;&gt;LastDay的博客&lt;/a&gt; on October 11, 2015.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[TCP协议的那些事（总结篇）]]></title>
  <link>http://localhost:4000/theme-setup/TCP</link>
  <id>http://localhost:4000/theme-setup/TCP</id>
  <published>2015-10-06T00:00:00-04:00</published>
  <updated>2015-10-06T00:00:00-04:00</updated>
  <author>
    <name>LastDay</name>
    <uri>http://localhost:4000</uri>
    <email>lastdays1122@icloud.com</email>
  </author>
  <content type="html">&lt;h2 id=&quot;section&quot;&gt;传输层概述&lt;/h2&gt;
&lt;p&gt;TCP协议特点：面向连接、字节流、可靠传输
### 面向链接：
1.使用TCP协议的双方必须先建立连接，并且双方都必须分配相应的内核资源。TCP的连接是全双工的，也就是说双方可以根据一个连接进行读写操作。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;字节流：&lt;/h3&gt;

&lt;p&gt;1.当发送方应用多次进行写操作的时候，TCP发送模块会先把数据放在发送缓冲区中，当TCP发送模块真正发送的时候，这些在发送缓冲区中的数据才可能被封装成一个或多个报文段发出。所有根据以上结论，应用程序执行的写操作的次数和TCP发送的报文段个数没有对应的数量关系。&lt;/p&gt;

&lt;p&gt;2.当接收端收到一个或多个报文段数据后，TCP模块必须把它们携带的应用层数据必须按照报文段序号把它们放到TCP接受缓冲区中。同时通知应用程序读取数据，这样应用程序就可以一次读出数据或多次读出数据，这取决于应用程序读缓冲区的大小。根据以上结论得出，TCP读取操作的次数跟接收报文段个数也没有固定的关系&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：发送端执行的写操作次数与接受端的读操作次数没有任何数量关系，应用程序的发送和接收是没有边界限制的，UDP就不是这样，在这里不详细说了&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如图TCP字节流服务过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150801192657747&quot; alt=&quot;字节流传输&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上就是字节流服务过程：&lt;/p&gt;

&lt;p&gt;从图中我们就可以看见，发送短调用的发送次数，和接收短的接受次数并不一样。所有的数据都是先进入缓冲区，在进行操作。封装成报文段进行发送或接收。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;可靠传输&lt;/h3&gt;

&lt;p&gt;TCP协议是可靠的传输协议，支持这种可靠传输的机制有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;发送应答机制：也就是说发送端发送的每个数据报文段都必须得到接收方的应答。&lt;/li&gt;
  &lt;li&gt;超时从穿机制：也就是说发送端在发送报文段数据后，本身就启动计时器，如果在规定时间内没有接到接受端的应答，那么就会重新发送这段数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcptcptcp&quot;&gt;要了解TCP在整个TCP协议栈中的作用我们需要分析一下TCP头部结构：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150801194315541&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;头部结构出现在每个TCP报文段中&lt;/li&gt;
  &lt;li&gt;头部结构包括20个字节的固定结构和40个字节的头部选项字段&lt;/li&gt;
  &lt;li&gt;16位源端口：该报文段数据来自哪里？&lt;/li&gt;
  &lt;li&gt;16位目的端口：该报文段数据传给哪个上层协议或应用程序。客户端基本使用临时端口号，而服务器选择知名的服务端口号，在Linux下，所有的知名服务端口号都定义在/etc/services文件夹下。
HTTP服务端口号为80，DNS服务端口号为53，FTP服务器端口为21。&lt;/li&gt;
  &lt;li&gt;32位序号：在tcp一次通信中（从建立连接到断开），在TCP协议在发送数据时会根据实际传输能力把数据分割成若干数据段，这32位序列号就是为这个数据段打上标记。&lt;/li&gt;
  &lt;li&gt;32位确认号：如果接收端没有接收到某一段数据会告诉发送端：“我没收到这段数据 请重新发送” 所以用确认号能保证数据的完整性&lt;/li&gt;
  &lt;li&gt;4位头部长度：标识有多少个4字节&lt;/li&gt;
  &lt;li&gt;URG：紧急指针是否有效&lt;/li&gt;
  &lt;li&gt;ACK：表示确认号是否有效&lt;/li&gt;
  &lt;li&gt;PSH：提示接收端应用程序应该立即从接收缓冲区中读取数据，为接收后续数据腾出空间。&lt;/li&gt;
  &lt;li&gt;RST：要求对方重新建立连接。&lt;/li&gt;
  &lt;li&gt;SYN：请求建立一个连接&lt;/li&gt;
  &lt;li&gt;FIN：同对方本端要关闭连接。&lt;/li&gt;
  &lt;li&gt;16位窗口大小：TCP流量控制。&lt;/li&gt;
  &lt;li&gt;16位校验和：接受端对tcp数据进行CRC算法检验tcp报文段在发送的过程中属否损坏。（包括数据部分）&lt;/li&gt;
  &lt;li&gt;16位紧急指针：表示最后一个紧急数据的下一字节的序号。&lt;/li&gt;
  &lt;li&gt;头部选项：最多包涵40个字节&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150801201537796&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.kind：说明选项类型。

2.length：表示该选项的总长度。

3.info：选项的具体信息。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kind类型如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150801201650363&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;tcp&quot;&gt;TCP连接状态转移过程&lt;/h1&gt;

&lt;h2 id=&quot;section-3&quot;&gt;服务器典型状态转移过程&lt;/h2&gt;

&lt;p&gt;1、首先服务器通过LISTEN系统调用，进入LISTEN状态，表示被动打开，被动等待客户端的连接，服务器监听到某个客户端的连接请求后，这个连接请求被称为同步报文段。之后TCP会将其放到内核等待队列中，并向客户端发送带SYN的确认报文段，之后该连接就会处于SYN_RCVD状态。那么这个时候如果服务器收到了客户端的ACK确认报文段，服务器进入ESTABLISHED，这个状态可以让双方进行数据传输。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;服务器关闭状态的转移过程&lt;/h2&gt;

&lt;p&gt;1、当客户端主动关闭连接时，客户端主动调用CLOSE，服务器接收到客户端的关闭报文段后，服务器返回ACK确认报文段，是连接进入CLOSE_WAIT状态。这个状态的就是跟字面意思一样，等待服务器关闭连接。这个时候服务器也会给客户端发送一个结束报文段，这个时候进入LAST_ACK。接下来就是等待客户端结束连接的最后一次确认。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;客户端连接状态转移过程&lt;/h2&gt;

&lt;p&gt;1、首先客户端通过CONNECT系统调用，给服务器发送同步报文段。使系统进入YSN_SENT状态。接下来会有两种可能，如果连接失败，该连接将会恢复到CLOSED状态，如果该客户多收到服务器返回的同步报文段，确认报文段，说明该客户端成功连接服务器。连接转移到ESTABLISHED状态（功能通上）&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;当客户端进行关闭时的状态转移过程&lt;/h2&gt;

&lt;p&gt;1、当客户端关闭时，客户端发送一个关闭连接报文段，同时连接进入SFIN_WAIT_1状态，如果接收到服务端ACK确认，连接状态进入FIN_WAIT_2状态。当服务端也发送了结束报文段，那么客户端也会发送ACK确认，客户端进入TIME_WAIT状态。&lt;/p&gt;

&lt;h3 id=&quot;tcp-1&quot;&gt;如图为TCP连接状态转移图：&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150802110224571&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参照图片详细了解连接转移过程&lt;/p&gt;

&lt;h1 id=&quot;tcp-2&quot;&gt;TCP建立连接和关闭连接的过程&lt;/h1&gt;

&lt;p&gt;首先我们来回顾下我们以前了解过的，TCP头部结构有6个标识位&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SYN：仅在三次握手建立连接时有效，表示同步报文段。&lt;/li&gt;
  &lt;li&gt;ACK：对TCP请求的确认标志。&lt;/li&gt;
  &lt;li&gt;FIN：标志用来结束一个TCP连接，标识此报文段是一个结束报文段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上就是我们讲到以下内容的时候需要用到的知识点&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;三次握手建立连接&lt;/h2&gt;

&lt;p&gt;开始介绍一下三次握手的过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一次握手：其实是客户端发送一个带有SYN的数据报文段发送给服务器，对应在图片中就是从主机A－&amp;gt;主机B（SYN＝1，seq＝i），seq为对应序列号为i。之后主机A进入SYN_SENT状态。同时等待服务器的确认&lt;/li&gt;
  &lt;li&gt;第二次握手：服务器收到同步报文段后（也就是带有SYN的同步报文段），必须确定客户的同步报文段。然后自己也发送一个带有SYN的报文段，对应到图片中也就死第二个报文段，其中SYN＝1，表示这是一个同步报文段，ACK＝1，表示这是一个确认报文段，确认序号值为i+1，序号值为j。&lt;/li&gt;
  &lt;li&gt;第三次握手：这次就是客户端收到确认同步报文段后，它向服务器发送确认包，对应到图片中也就是第三个报文段，ack＝1也就是表示这是一个确认报文段，确认序号为j+1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三次握手建立后，客户端与服务器开始传送数据。&lt;/p&gt;

&lt;p&gt;三次握手示意图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150803153852016&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;四次握手关闭连接&lt;/h2&gt;

&lt;p&gt;接下来，我们来介绍下四次握手关闭&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一次握手：表示客户端A发送给服务器一个带有SYN的结束报文段，用来关闭客户端A到服务端B的数据传送，对应到图片中也就是第一个报文段，FIN＝1，seq＝i，表示一个结束报文段&lt;/li&gt;
  &lt;li&gt;第二次握手：服务端B接收到这个结束报文段后，它返回一个确认报文段，对应到图片中就是第二个确认报文段。其中ACK＝1，ack＝i+i，表示一个确认报文段，确认序号为i+1.&lt;/li&gt;
  &lt;li&gt;第三次握手：服务器B关闭与客户端A的连接，他发送一个带有SYN结束报文段，对应图片上第三个报文段，其中  SYN＝1，seq＝j，表示结束报文段，序号为j。&lt;/li&gt;
  &lt;li&gt;第四次握手：客户端A返回一个确认报文段，其中确认序号为j+1，对应图片上为第四个报文段，ACK＝1，ack＝j+1。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-9&quot;&gt;总结：为什么建立连接需要三次握手？为什么关闭连接需要四次握手？为什么建立连接需要三次握手呢？&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;接受连接缺需要4次握手，LISTEN状态下建立连接后，它可以把同步报文段和确认报文段合并成一个报文段来进行发送，确认报文段起到应达作用，同步报文段起到同步作用，也就是三次握手中的第二个报文段其实是发挥了两个作用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在关闭连接时，当收到对方的结束报文段时，表示对方没有数据发给你了，但是自己的数据未必全部发送完毕，所以你可能还需要继续发送一些数据之后在发送结束报文段给对方了表示你同意现在可以断开连接，所以关闭连接需要四次握手&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果把三次握手改成两次握手，就有可能发生死锁。关于死锁，（搜索一下）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;四次握手示意图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150803153635912&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;timewait&quot;&gt;TIME_WAIT状态的含义&lt;/h2&gt;

&lt;p&gt;在TCP详解（二）中，提到过，当客户端收到服务器的结束报文段后，不会立即进入CLOSED状态，而是转移到TIME_WAIT状态下，在这个状态下，客户端要等待一段2倍的MSL（报文段最大生存时间）时间。等待这个时间后才能完全关闭。TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活msl秒即被丢弃，另一个方向上的应答最多存活msl秒也被丢弃。 通过实施这个规则，我们就能保证每成功建立一个TCP连接时。来自该链接先前化身的重复分组都已经在网络中消逝了。&lt;/p&gt;

&lt;h3 id=&quot;timewait-1&quot;&gt;TIME_WAIT状态存在的原因有两点：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;可靠的终止TCP连接:&lt;/p&gt;

    &lt;p&gt;例如在四次握手时，如果第三个报文段丢失，这个时候服务器将重新发送这个报文段，所以客户端需要停留在摸个状态来处理重复信息。否则客户端将会向服务器发送复位报文段，让服务器误认为这是一个错误&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;保证延迟来的TCP报文段有足够的时间去识别并丢弃:&lt;/p&gt;

    &lt;p&gt;在Linux系统上，一个TCP端口不能被同时打开多次，当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用该连接占用的端口建立一个新连接。
  但是我们反过来考虑，如果不存在这种机制，那么服务器刚关闭连接，又建立了一个类似的连接，成为“原链接化身”，这个“化身“就有可能就收到属于原来连接的数据报文段，这种情况是不允许出现的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;imewait&quot;&gt;IME_WAIT状态过多的缺点：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;根据上诉，我们可以了解到，如果IME_WAIT状态过多会占用大量的端口号，占用系用资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;imewait-1&quot;&gt;IME_WAIT状态过多的处理方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;修改内核参数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;尽可能被动关闭连接&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将长连接修改为短连接&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过套接字选项尽可能回避IME_WAIT状态带来的负面影响&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;rst&quot;&gt;RST复位报文段&lt;/h1&gt;

&lt;h2 id=&quot;rst-1&quot;&gt;RST复位报文段的作用&lt;/h2&gt;

&lt;p&gt;曾经在&lt;a href=&quot;http://blog.csdn.net/lastdays_l/article/details/47189621&quot;&gt;TCP协议详解（一）&lt;/a&gt;中介绍了TCP的头部信息，头部中有6位的标识字段，这6位中有一位时RST标志位。如果在TCP某一个报文段中，RST的标志位＝1，就说明这个报文段是RST报文段，也就是复位报文段，在某些情况下，TCP连接的一端会像另一端发送携带RST数据报文段，用来通知对方关闭连接或者重新连接。&lt;/p&gt;

&lt;p&gt;RST报文段是请求对方连接，发送此报文段的时机有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在连接建立时&lt;/li&gt;
  &lt;li&gt;在中间发送数据时&lt;/li&gt;
  &lt;li&gt;在连接关闭时&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上三种情况都有可能发送RST复位报文段。&lt;/p&gt;

&lt;h2 id=&quot;rst-2&quot;&gt;发送RST报文段情况&lt;/h2&gt;

&lt;h3 id=&quot;rst-3&quot;&gt;RST复位报文段出现的原因很多，在网路编程中，也很难排查原因在哪？所以列出一些常见的原因，分享给大家：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;端口未打开：如果服务器程序端口位打开，而客户端来进行连接。&lt;/li&gt;
  &lt;li&gt;请求超时：例如一个客户端连接服务器时，Connect系统调用返回时失败，出现错误信息，但是这个时候使用ping命令进行测试没有出现丢包现象，如果在使用抓包工具查看，客户端收到服务器端的同步报文段之后，发送了RST复位报文段，这就有可能是请求超时的原因&lt;/li&gt;
  &lt;li&gt;提前关闭：如果服务端关闭或者异常终止连接，而且由于网络故障原因，对方没有接收到结束报文段没这个时候客户端还维护着原来的连接，这个时候我们把服务器重新启动，但是次服务器已经没有任何该连接的信息了。如果此时客户端向服务器写一个数据，对方就会回应一个RST复位报文段&lt;/li&gt;
  &lt;li&gt;在一个已关闭的Socket上收到数据：这种情况看见的不多，比如说连接关闭后，网络中游离的数据包到达目标段，此时目标段发现这个连接已经关闭，复位报文段就会发送到另一个连接。&lt;/li&gt;
  &lt;li&gt;异常终止一个连接：在数据交换完成之后，发送数据报文段。&lt;/li&gt;
  &lt;li&gt;向处于LISTEN状态的端口发送数据：会收到对端发送的RST复位报文段&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-10&quot;&gt;了解以上内容有助于网络编程的调试。&lt;/h3&gt;

&lt;h1 id=&quot;tcp-3&quot;&gt;TCP可靠传输机制&lt;/h1&gt;
&lt;p&gt;##TCP超时重传&lt;/p&gt;

&lt;p&gt;如果网络异常救出出现超时或者丢包，TCP模块必须能够重传在超时时间内对方未收到的TCP报文段。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TCP模块为每个TCP报文段维护一个重传定时器：该定时器在TCP报文段第一次被发送时启动，如果超时时间内没收到接收方的应答，TCP模块将重传TCP报文段，并重置定时器&lt;/li&gt;
  &lt;li&gt;如果超时，则进行重传，重新设置定时器&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcp-4&quot;&gt;TCP拥塞控制&lt;/h2&gt;

&lt;p&gt;TCP模块的任务&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;提高网络利用率&lt;/li&gt;
  &lt;li&gt;降低丢包率&lt;/li&gt;
  &lt;li&gt;拥塞控制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中拥塞控制，还有TCP的流量控制，这种控制机制都是为了TCP的可靠传输设置的，拥塞控制的任务是确保子网能承载所到达的流量。这是一个全局性问题，涉及到各方面的行为（刚兴趣可以自己去搜索下，这里就不做过多介绍）。&lt;/p&gt;

&lt;p&gt;关于拥塞控制我们进行详细的讲解：&lt;/p&gt;

&lt;p&gt;###拥塞控制的反馈过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150806104035106&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拥塞控制的最终受控变量是发送端向网络中一次连续写入的数据量，我们称为我们称为发送窗口。不过发送窗口最终以TCP报文段来发送数据，进而发送端口就限定了连续发送的TCP报文段的数量，如图所示，发送窗口被称为SWND，这些报文段的最大长度被称为MSS发送端需要合理的选择发送窗口，如果发送窗口太小，就会出现网络延迟现象，如果发送窗口过大，就容易导致网络拥塞。接收方可以通过接收通告收窗口来控制发送端的发送窗口，但是这看起来也不够，所以在发送端引入一个称为拥塞窗口的状态变量，拥塞窗口简称CWND，接收通告窗口简称RWND。图像中就显示了拥塞控制的闭环反馈控制。&lt;/p&gt;

&lt;p&gt;###几种拥塞控制的方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TCP慢启动&lt;/li&gt;
  &lt;li&gt;拥塞避免&lt;/li&gt;
  &lt;li&gt;快速重传&lt;/li&gt;
  &lt;li&gt;快速恢复&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;慢启动，拥塞避免图：&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150806104111167&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们知道那个发送端维持一个拥塞窗口的状态变量，拥塞窗口简称CWND，拥塞窗口的大小取决于网络的拥塞程度，并且动态的变化。CWND的处理原则就是只要网络中没有出现拥塞现象，拥塞窗口就在大一些，以便把更多的分组发送出去。只要网络中出现拥塞，拥塞窗口就减少一些。以减少注入到网络分组中的数量。&lt;/p&gt;

&lt;p&gt;我们现在来分析拥塞控制的算法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;慢启动：当主机开始发送数据时，如果把大量的字节注入到网络，那么就有可能引起网络拥塞。因为我们现在并不清楚网络的负载情况。所以比较好的方法就是自动去探测一下，由小到大满满增大拥塞窗口的数值，通常在刚刚开始发送报文段的时候，先把拥塞端口设置为一个最大报文段，而在每个在收到新的报文段的时候，把拥塞窗口的大小加1，按照指数规律增长，也就是增大一个最大报文段的数值。我们用同样的方法逐渐增大发送端的拥塞窗口。可以使分组注入到网络中的数据更加合理。&lt;/p&gt;

    &lt;p&gt;对应到图示中，横坐标从0－&amp;gt;3都是满启动的状态。我们为了防止因为增大造成的网络拥塞，我们还需要设置一个满启动的ssthresh值，关于慢启动的ssthresh用法就是如果拥塞窗口小于ssthresh值，就应用慢启动算法。如果拥塞窗口大于ssthresh值，就停止应用慢启动算法。而改用拥塞避免算法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拥塞避免：拥塞避免算法为了让拥塞窗口缓慢的增长，就是每经过一个往返的时间，就把发送方的拥塞窗口加1，而不是成倍增长，这样拥塞窗口是按照线性规律缓慢增长。对应到图像中就是那个明显的拐点以后，都是拥塞避免的算法执行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;仅仅应用 慢启动和拥塞控制，不可能达到控制网络拥塞&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;接下来介绍快速重传，快速恢复&lt;/h3&gt;

&lt;p&gt;在很多情况下，TCP发送端都可以接受到重复的确认报文段，例如TCP报文段缺失等等，发送端如果连接接收到三个重复的确认报文段，就可以判断网络中发生了拥塞。这个时候使用快速重传，快速恢复算法。快速重传算法我先要求接受端每收到一个失去的报文到，就立即发送重传确认。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;拥塞发生或有三个处理不步骤：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;拥塞发生后的处理过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;收到三个重复的确认处理过程：当收到三个重复的报文段时，重新计算满启动的ssthresh值，就是将ssthresh值减半，然后立即重传重传报文段。&lt;/li&gt;
  &lt;li&gt;收到1个重复确认处理过程：将慢启动的ssthresh值减半后，开始执行拥塞避免算法，而不是刚刚提到的慢启动算法。&lt;/li&gt;
  &lt;li&gt;收到新数据后的处理过程：重新设置慢启动的ssthresh值，使得拥塞窗口等于当前设置的ssthresh值。&lt;/li&gt;
&lt;/ul&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/theme-setup/TCP&quot;&gt;TCP协议的那些事（总结篇）&lt;/a&gt; was originally published by LastDay at &lt;a href=&quot;http://localhost:4000&quot;&gt;LastDay的博客&lt;/a&gt; on October 06, 2015.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[OS X内存管理：从源码进行分析（一）]]></title>
  <link>http://localhost:4000/theme-setup/OS%20X</link>
  <id>http://localhost:4000/theme-setup/OS X</id>
  <published>2015-10-05T00:00:00-04:00</published>
  <updated>2015-10-05T00:00:00-04:00</updated>
  <author>
    <name>LastDay</name>
    <uri>http://localhost:4000</uri>
    <email>lastdays1122@icloud.com</email>
  </author>
  <content type="html">&lt;p&gt;通过对《Objective-C高级编程》的学习，就来总结一下。&lt;/p&gt;

&lt;p&gt;在Objective-C中的内存管理中，autorelease就是自动释放，看上去很像ARC对不对？但是呢，却并不是，其实有点像我们曾经在学习C语言中的局部变量&lt;/p&gt;

&lt;h2 id=&quot;gnustep&quot;&gt;GNUstep的实现&lt;/h2&gt;

&lt;p&gt;就下来就详细的总结一下autorelease的实现原理。由于NSObject类的Foundation框架并没有被开源，所以我们就研究一下GNUstep这个开源软件。&lt;/p&gt;

&lt;p&gt;首先看一个源代码&lt;/p&gt;

&lt;p&gt;```
[obj autorelease]&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;这个源代码实际是调用了 NSObject类的autorelease方法。&lt;/p&gt;

&lt;p&gt;```
-(id)autorelease
{
	[NSAutoreleasePool addObject:self];
}&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;从以上这个代码中我们就可以分析出来，其实autorelease实际上就是调用了NSAutoreleasePool中的addObject方法&lt;/p&gt;

&lt;p&gt;看到了以上的内容，我们就需要详细的探讨一下NSAutoreleasePool的实现原理。以下是我摘要的源代码，因为NSAutoreleasePool的源代码的实现太复杂了，所以这里的源代码是经过简化后的&lt;/p&gt;

&lt;p&gt;NSAutoreleasePool.m addObject&lt;/p&gt;

&lt;p&gt;```
+(void)addObject:(id)anObj
{
	NSAutoreleasePool *pool = 取得我们正在运用的NSAutoreleasePool;
	if（pool！=nil）{
		[pool addObject: anObj];
	} else {
		NSLog(@”NSAutoreleasePool对象不存在”);
	}
}&lt;/p&gt;

&lt;p&gt;```
addObject 类方法调用正在使用的NSAutoreleasePool对象的addObject，这句话可能会有一些难理解，没关系，接着看一组源代码。&lt;/p&gt;

&lt;p&gt;```
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
id obj = [[NSObject alloc] init];
[obj autorelease];&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;通过上面的代码我们就可以看出，被赋予pool变量，那么就是正在使用NSAutoreleasePool的实例化对象。&lt;/p&gt;

&lt;p&gt;在我自己学习的过程中，还看到另外一种嵌套的方式&lt;/p&gt;

&lt;p&gt;```
NSAutoreleasePool *pool0 = [[NSAutoreleasePool alloc] init];
	NSAutoreleasePool *pool1 = [[NSAutoreleasePool alloc] init];
		NSAutoreleasePool *pool2 = [[NSAutoreleasePool alloc] init];&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	id obj = [[NSObject alloc] init];
	[obj autorelease];
	
	[pool2 drain];
[pool1 drain]; [pool0 drain];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;在这种嵌套结构中，pool2为NSAutoreleasePool的使用对象，遵循使用最内测的对象想这个原则。&lt;/p&gt;

&lt;p&gt;看一下addObject的实现原理。其实就是调用了array的addObject方法&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;-（void）addObject ：（id）anObj
{
	[array addObject : anObj];
}&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;以上就是GNUstep实现，其实GNUstep使用的就是连接列表，这跟NSNutableArray对象的中追加的原理是一样的，就是说如果我们调用了autorelease方法，这个调用autorelease方法的对象就会被追加到NSAutoreleasePool的数组中&lt;/p&gt;

&lt;p&gt;```
[pool drain];&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;通过drain就可以删除正在使用NSAutoreleasePool的对象&lt;/p&gt;

&lt;p&gt;看一下drain的实现原理&lt;/p&gt;

&lt;p&gt;```
-（void）drain
{
	for(id obj in array){
		[obj release];
	}
	[array release];
}&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;通过每次的循环都在调用release方法来实现释放。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;苹果的实现&lt;/h2&gt;

&lt;p&gt;以下为objc4库中的autorelease实现原理&lt;/p&gt;

&lt;p&gt;```
class AutoreleasePoolPage
{
	static inline void *push()
	{
		//在这里进行NSAutoreleasePool的生成
	}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void *pop()
{
	//废弃掉NSAutoreleasePool类对象
	releaseAll();
}
static inline id autorelease(id obj)
{
	//这里就相当于NSAutoreleasePool类的addObject方法
	AutoreleasePoolPage * autoreleasePoolPage = 取得正在使用AutoreleasePoolPage类的对象；
	autoreleasePoolPage-&amp;gt;add(obj);
	
}
id *add(id obj)
{
	//讲对象追加到数组中
}
void releaseAll()
{
	//调用release实例
} }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;void *obj_ autoreleasePoolPush(void)
{
	return autoreleasePoolPage::push();
}
void *obj_ autoreleasePoolPop(void)
{
	return autoreleasePoolPage::pop(void *ctxt);
}
void *obj_ autorelease(id obj)
{
	return autoreleasePoolPage::autorelease(obj);
}&lt;/p&gt;

&lt;p&gt;c++中虽然有类似NSNutableArray的动态数组，但是行为却和GNUstep的实现完全不同。&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;首先先来看一下NSAutoreleasePool类方法和autorelease方法的运行过程。以及和从从从c++的对象关系&lt;/p&gt;

&lt;p&gt;```
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
//相当于obj_ autoreleasePoolPush()&lt;/p&gt;

&lt;p&gt;id obj = [[NSObject alloc] init];&lt;/p&gt;

&lt;p&gt;[obj autorelease];
//相当于*obj_ autorelease(obj)&lt;/p&gt;

&lt;p&gt;[pool drain];
//相当于*obj_ autoreleasePoolPop(pool)&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/theme-setup/OS%20X&quot;&gt;OS X内存管理：从源码进行分析（一）&lt;/a&gt; was originally published by LastDay at &lt;a href=&quot;http://localhost:4000&quot;&gt;LastDay的博客&lt;/a&gt; on October 05, 2015.&lt;/p&gt;</content>
</entry>

</feed>
